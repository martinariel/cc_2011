<?php


/**
 * Base class that represents a query for the 'persona' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.5.6 on:
 *
 * Fri Mar  4 00:48:22 2011
 *
 * @method     PersonaQuery orderById($order = Criteria::ASC) Order by the id column
 * @method     PersonaQuery orderByNombre($order = Criteria::ASC) Order by the nombre column
 * @method     PersonaQuery orderByDni($order = Criteria::ASC) Order by the dni column
 * @method     PersonaQuery orderByFechaNacimiento($order = Criteria::ASC) Order by the fecha_nacimiento column
 * @method     PersonaQuery orderBySexo($order = Criteria::ASC) Order by the sexo column
 * @method     PersonaQuery orderByPeso($order = Criteria::ASC) Order by the peso column
 * @method     PersonaQuery orderByAltura($order = Criteria::ASC) Order by the altura column
 * @method     PersonaQuery orderByEmail($order = Criteria::ASC) Order by the email column
 * @method     PersonaQuery orderByTelefono($order = Criteria::ASC) Order by the telefono column
 * @method     PersonaQuery orderByCelular($order = Criteria::ASC) Order by the celular column
 * @method     PersonaQuery orderByCalzado($order = Criteria::ASC) Order by the calzado column
 * @method     PersonaQuery orderByPantalon($order = Criteria::ASC) Order by the pantalon column
 * @method     PersonaQuery orderByCamisa($order = Criteria::ASC) Order by the camisa column
 * @method     PersonaQuery orderByObservaciones($order = Criteria::ASC) Order by the observaciones column
 * @method     PersonaQuery orderByFechaActualizacion($order = Criteria::ASC) Order by the fecha_actualizacion column
 * @method     PersonaQuery orderByNacionalidadId($order = Criteria::ASC) Order by the nacionalidad_id column
 * @method     PersonaQuery orderByCreatedAt($order = Criteria::ASC) Order by the created_at column
 *
 * @method     PersonaQuery groupById() Group by the id column
 * @method     PersonaQuery groupByNombre() Group by the nombre column
 * @method     PersonaQuery groupByDni() Group by the dni column
 * @method     PersonaQuery groupByFechaNacimiento() Group by the fecha_nacimiento column
 * @method     PersonaQuery groupBySexo() Group by the sexo column
 * @method     PersonaQuery groupByPeso() Group by the peso column
 * @method     PersonaQuery groupByAltura() Group by the altura column
 * @method     PersonaQuery groupByEmail() Group by the email column
 * @method     PersonaQuery groupByTelefono() Group by the telefono column
 * @method     PersonaQuery groupByCelular() Group by the celular column
 * @method     PersonaQuery groupByCalzado() Group by the calzado column
 * @method     PersonaQuery groupByPantalon() Group by the pantalon column
 * @method     PersonaQuery groupByCamisa() Group by the camisa column
 * @method     PersonaQuery groupByObservaciones() Group by the observaciones column
 * @method     PersonaQuery groupByFechaActualizacion() Group by the fecha_actualizacion column
 * @method     PersonaQuery groupByNacionalidadId() Group by the nacionalidad_id column
 * @method     PersonaQuery groupByCreatedAt() Group by the created_at column
 *
 * @method     PersonaQuery leftJoin($relation) Adds a LEFT JOIN clause to the query
 * @method     PersonaQuery rightJoin($relation) Adds a RIGHT JOIN clause to the query
 * @method     PersonaQuery innerJoin($relation) Adds a INNER JOIN clause to the query
 *
 * @method     PersonaQuery leftJoinNacionalidad($relationAlias = null) Adds a LEFT JOIN clause to the query using the Nacionalidad relation
 * @method     PersonaQuery rightJoinNacionalidad($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Nacionalidad relation
 * @method     PersonaQuery innerJoinNacionalidad($relationAlias = null) Adds a INNER JOIN clause to the query using the Nacionalidad relation
 *
 * @method     PersonaQuery leftJoinMedia($relationAlias = null) Adds a LEFT JOIN clause to the query using the Media relation
 * @method     PersonaQuery rightJoinMedia($relationAlias = null) Adds a RIGHT JOIN clause to the query using the Media relation
 * @method     PersonaQuery innerJoinMedia($relationAlias = null) Adds a INNER JOIN clause to the query using the Media relation
 *
 * @method     PersonaQuery leftJoinPersonaCasting($relationAlias = null) Adds a LEFT JOIN clause to the query using the PersonaCasting relation
 * @method     PersonaQuery rightJoinPersonaCasting($relationAlias = null) Adds a RIGHT JOIN clause to the query using the PersonaCasting relation
 * @method     PersonaQuery innerJoinPersonaCasting($relationAlias = null) Adds a INNER JOIN clause to the query using the PersonaCasting relation
 *
 * @method     PersonaQuery leftJoinPersonaScouting($relationAlias = null) Adds a LEFT JOIN clause to the query using the PersonaScouting relation
 * @method     PersonaQuery rightJoinPersonaScouting($relationAlias = null) Adds a RIGHT JOIN clause to the query using the PersonaScouting relation
 * @method     PersonaQuery innerJoinPersonaScouting($relationAlias = null) Adds a INNER JOIN clause to the query using the PersonaScouting relation
 *
 * @method     PersonaQuery leftJoinPersonaLenguaje($relationAlias = null) Adds a LEFT JOIN clause to the query using the PersonaLenguaje relation
 * @method     PersonaQuery rightJoinPersonaLenguaje($relationAlias = null) Adds a RIGHT JOIN clause to the query using the PersonaLenguaje relation
 * @method     PersonaQuery innerJoinPersonaLenguaje($relationAlias = null) Adds a INNER JOIN clause to the query using the PersonaLenguaje relation
 *
 * @method     PersonaQuery leftJoinPersonaLabel($relationAlias = null) Adds a LEFT JOIN clause to the query using the PersonaLabel relation
 * @method     PersonaQuery rightJoinPersonaLabel($relationAlias = null) Adds a RIGHT JOIN clause to the query using the PersonaLabel relation
 * @method     PersonaQuery innerJoinPersonaLabel($relationAlias = null) Adds a INNER JOIN clause to the query using the PersonaLabel relation
 *
 * @method     Persona findOne(PropelPDO $con = null) Return the first Persona matching the query
 * @method     Persona findOneOrCreate(PropelPDO $con = null) Return the first Persona matching the query, or a new Persona object populated from the query conditions when no match is found
 *
 * @method     Persona findOneById(int $id) Return the first Persona filtered by the id column
 * @method     Persona findOneByNombre(string $nombre) Return the first Persona filtered by the nombre column
 * @method     Persona findOneByDni(string $dni) Return the first Persona filtered by the dni column
 * @method     Persona findOneByFechaNacimiento(string $fecha_nacimiento) Return the first Persona filtered by the fecha_nacimiento column
 * @method     Persona findOneBySexo(string $sexo) Return the first Persona filtered by the sexo column
 * @method     Persona findOneByPeso(int $peso) Return the first Persona filtered by the peso column
 * @method     Persona findOneByAltura(int $altura) Return the first Persona filtered by the altura column
 * @method     Persona findOneByEmail(string $email) Return the first Persona filtered by the email column
 * @method     Persona findOneByTelefono(string $telefono) Return the first Persona filtered by the telefono column
 * @method     Persona findOneByCelular(string $celular) Return the first Persona filtered by the celular column
 * @method     Persona findOneByCalzado(string $calzado) Return the first Persona filtered by the calzado column
 * @method     Persona findOneByPantalon(string $pantalon) Return the first Persona filtered by the pantalon column
 * @method     Persona findOneByCamisa(string $camisa) Return the first Persona filtered by the camisa column
 * @method     Persona findOneByObservaciones(string $observaciones) Return the first Persona filtered by the observaciones column
 * @method     Persona findOneByFechaActualizacion(string $fecha_actualizacion) Return the first Persona filtered by the fecha_actualizacion column
 * @method     Persona findOneByNacionalidadId(int $nacionalidad_id) Return the first Persona filtered by the nacionalidad_id column
 * @method     Persona findOneByCreatedAt(string $created_at) Return the first Persona filtered by the created_at column
 *
 * @method     array findById(int $id) Return Persona objects filtered by the id column
 * @method     array findByNombre(string $nombre) Return Persona objects filtered by the nombre column
 * @method     array findByDni(string $dni) Return Persona objects filtered by the dni column
 * @method     array findByFechaNacimiento(string $fecha_nacimiento) Return Persona objects filtered by the fecha_nacimiento column
 * @method     array findBySexo(string $sexo) Return Persona objects filtered by the sexo column
 * @method     array findByPeso(int $peso) Return Persona objects filtered by the peso column
 * @method     array findByAltura(int $altura) Return Persona objects filtered by the altura column
 * @method     array findByEmail(string $email) Return Persona objects filtered by the email column
 * @method     array findByTelefono(string $telefono) Return Persona objects filtered by the telefono column
 * @method     array findByCelular(string $celular) Return Persona objects filtered by the celular column
 * @method     array findByCalzado(string $calzado) Return Persona objects filtered by the calzado column
 * @method     array findByPantalon(string $pantalon) Return Persona objects filtered by the pantalon column
 * @method     array findByCamisa(string $camisa) Return Persona objects filtered by the camisa column
 * @method     array findByObservaciones(string $observaciones) Return Persona objects filtered by the observaciones column
 * @method     array findByFechaActualizacion(string $fecha_actualizacion) Return Persona objects filtered by the fecha_actualizacion column
 * @method     array findByNacionalidadId(int $nacionalidad_id) Return Persona objects filtered by the nacionalidad_id column
 * @method     array findByCreatedAt(string $created_at) Return Persona objects filtered by the created_at column
 *
 * @package    propel.generator.lib.model.om
 */
abstract class BasePersonaQuery extends ModelCriteria
{

	/**
	 * Initializes internal state of BasePersonaQuery object.
	 *
	 * @param     string $dbName The dabase name
	 * @param     string $modelName The phpName of a model, e.g. 'Book'
	 * @param     string $modelAlias The alias for the model in this query, e.g. 'b'
	 */
	public function __construct($dbName = 'propel', $modelName = 'Persona', $modelAlias = null)
	{
		parent::__construct($dbName, $modelName, $modelAlias);
	}

	/**
	 * Returns a new PersonaQuery object.
	 *
	 * @param     string $modelAlias The alias of a model in the query
	 * @param     Criteria $criteria Optional Criteria to build the query from
	 *
	 * @return    PersonaQuery
	 */
	public static function create($modelAlias = null, $criteria = null)
	{
		if ($criteria instanceof PersonaQuery) {
			return $criteria;
		}
		$query = new PersonaQuery();
		if (null !== $modelAlias) {
			$query->setModelAlias($modelAlias);
		}
		if ($criteria instanceof Criteria) {
			$query->mergeWith($criteria);
		}
		return $query;
	}

	/**
	 * Find object by primary key
	 * Use instance pooling to avoid a database query if the object exists
	 * <code>
	 * $obj  = $c->findPk(12, $con);
	 * </code>
	 * @param     mixed $key Primary key to use for the query
	 * @param     PropelPDO $con an optional connection object
	 *
	 * @return    Persona|array|mixed the result, formatted by the current formatter
	 */
	public function findPk($key, $con = null)
	{
		if ((null !== ($obj = PersonaPeer::getInstanceFromPool((string) $key))) && $this->getFormatter()->isObjectFormatter()) {
			// the object is alredy in the instance pool
			return $obj;
		} else {
			// the object has not been requested yet, or the formatter is not an object formatter
			$criteria = $this->isKeepQuery() ? clone $this : $this;
			$stmt = $criteria
				->filterByPrimaryKey($key)
				->getSelectStatement($con);
			return $criteria->getFormatter()->init($criteria)->formatOne($stmt);
		}
	}

	/**
	 * Find objects by primary key
	 * <code>
	 * $objs = $c->findPks(array(12, 56, 832), $con);
	 * </code>
	 * @param     array $keys Primary keys to use for the query
	 * @param     PropelPDO $con an optional connection object
	 *
	 * @return    PropelObjectCollection|array|mixed the list of results, formatted by the current formatter
	 */
	public function findPks($keys, $con = null)
	{	
		$criteria = $this->isKeepQuery() ? clone $this : $this;
		return $this
			->filterByPrimaryKeys($keys)
			->find($con);
	}

	/**
	 * Filter the query by primary key
	 *
	 * @param     mixed $key Primary key to use for the query
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByPrimaryKey($key)
	{
		return $this->addUsingAlias(PersonaPeer::ID, $key, Criteria::EQUAL);
	}

	/**
	 * Filter the query by a list of primary keys
	 *
	 * @param     array $keys The list of primary key to use for the query
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByPrimaryKeys($keys)
	{
		return $this->addUsingAlias(PersonaPeer::ID, $keys, Criteria::IN);
	}

	/**
	 * Filter the query on the id column
	 * 
	 * @param     int|array $id The value to use as filter.
	 *            Accepts an associative array('min' => $minValue, 'max' => $maxValue)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterById($id = null, $comparison = null)
	{
		if (is_array($id) && null === $comparison) {
			$comparison = Criteria::IN;
		}
		return $this->addUsingAlias(PersonaPeer::ID, $id, $comparison);
	}

	/**
	 * Filter the query on the nombre column
	 * 
	 * @param     string $nombre The value to use as filter.
	 *            Accepts wildcards (* and % trigger a LIKE)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByNombre($nombre = null, $comparison = null)
	{
		if (null === $comparison) {
			if (is_array($nombre)) {
				$comparison = Criteria::IN;
			} elseif (preg_match('/[\%\*]/', $nombre)) {
				$nombre = str_replace('*', '%', $nombre);
				$comparison = Criteria::LIKE;
			}
		}
		return $this->addUsingAlias(PersonaPeer::NOMBRE, $nombre, $comparison);
	}

	/**
	 * Filter the query on the dni column
	 * 
	 * @param     string $dni The value to use as filter.
	 *            Accepts wildcards (* and % trigger a LIKE)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByDni($dni = null, $comparison = null)
	{
		if (null === $comparison) {
			if (is_array($dni)) {
				$comparison = Criteria::IN;
			} elseif (preg_match('/[\%\*]/', $dni)) {
				$dni = str_replace('*', '%', $dni);
				$comparison = Criteria::LIKE;
			}
		}
		return $this->addUsingAlias(PersonaPeer::DNI, $dni, $comparison);
	}

	/**
	 * Filter the query on the fecha_nacimiento column
	 * 
	 * @param     string|array $fechaNacimiento The value to use as filter.
	 *            Accepts an associative array('min' => $minValue, 'max' => $maxValue)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByFechaNacimiento($fechaNacimiento = null, $comparison = null)
	{
		if (is_array($fechaNacimiento)) {
			$useMinMax = false;
			if (isset($fechaNacimiento['min'])) {
				$this->addUsingAlias(PersonaPeer::FECHA_NACIMIENTO, $fechaNacimiento['min'], Criteria::GREATER_EQUAL);
				$useMinMax = true;
			}
			if (isset($fechaNacimiento['max'])) {
				$this->addUsingAlias(PersonaPeer::FECHA_NACIMIENTO, $fechaNacimiento['max'], Criteria::LESS_EQUAL);
				$useMinMax = true;
			}
			if ($useMinMax) {
				return $this;
			}
			if (null === $comparison) {
				$comparison = Criteria::IN;
			}
		}
		return $this->addUsingAlias(PersonaPeer::FECHA_NACIMIENTO, $fechaNacimiento, $comparison);
	}

	/**
	 * Filter the query on the sexo column
	 * 
	 * @param     string $sexo The value to use as filter.
	 *            Accepts wildcards (* and % trigger a LIKE)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterBySexo($sexo = null, $comparison = null)
	{
		if (null === $comparison) {
			if (is_array($sexo)) {
				$comparison = Criteria::IN;
			} elseif (preg_match('/[\%\*]/', $sexo)) {
				$sexo = str_replace('*', '%', $sexo);
				$comparison = Criteria::LIKE;
			}
		}
		return $this->addUsingAlias(PersonaPeer::SEXO, $sexo, $comparison);
	}

	/**
	 * Filter the query on the peso column
	 * 
	 * @param     int|array $peso The value to use as filter.
	 *            Accepts an associative array('min' => $minValue, 'max' => $maxValue)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByPeso($peso = null, $comparison = null)
	{
		if (is_array($peso)) {
			$useMinMax = false;
			if (isset($peso['min'])) {
				$this->addUsingAlias(PersonaPeer::PESO, $peso['min'], Criteria::GREATER_EQUAL);
				$useMinMax = true;
			}
			if (isset($peso['max'])) {
				$this->addUsingAlias(PersonaPeer::PESO, $peso['max'], Criteria::LESS_EQUAL);
				$useMinMax = true;
			}
			if ($useMinMax) {
				return $this;
			}
			if (null === $comparison) {
				$comparison = Criteria::IN;
			}
		}
		return $this->addUsingAlias(PersonaPeer::PESO, $peso, $comparison);
	}

	/**
	 * Filter the query on the altura column
	 * 
	 * @param     int|array $altura The value to use as filter.
	 *            Accepts an associative array('min' => $minValue, 'max' => $maxValue)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByAltura($altura = null, $comparison = null)
	{
		if (is_array($altura)) {
			$useMinMax = false;
			if (isset($altura['min'])) {
				$this->addUsingAlias(PersonaPeer::ALTURA, $altura['min'], Criteria::GREATER_EQUAL);
				$useMinMax = true;
			}
			if (isset($altura['max'])) {
				$this->addUsingAlias(PersonaPeer::ALTURA, $altura['max'], Criteria::LESS_EQUAL);
				$useMinMax = true;
			}
			if ($useMinMax) {
				return $this;
			}
			if (null === $comparison) {
				$comparison = Criteria::IN;
			}
		}
		return $this->addUsingAlias(PersonaPeer::ALTURA, $altura, $comparison);
	}

	/**
	 * Filter the query on the email column
	 * 
	 * @param     string $email The value to use as filter.
	 *            Accepts wildcards (* and % trigger a LIKE)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByEmail($email = null, $comparison = null)
	{
		if (null === $comparison) {
			if (is_array($email)) {
				$comparison = Criteria::IN;
			} elseif (preg_match('/[\%\*]/', $email)) {
				$email = str_replace('*', '%', $email);
				$comparison = Criteria::LIKE;
			}
		}
		return $this->addUsingAlias(PersonaPeer::EMAIL, $email, $comparison);
	}

	/**
	 * Filter the query on the telefono column
	 * 
	 * @param     string $telefono The value to use as filter.
	 *            Accepts wildcards (* and % trigger a LIKE)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByTelefono($telefono = null, $comparison = null)
	{
		if (null === $comparison) {
			if (is_array($telefono)) {
				$comparison = Criteria::IN;
			} elseif (preg_match('/[\%\*]/', $telefono)) {
				$telefono = str_replace('*', '%', $telefono);
				$comparison = Criteria::LIKE;
			}
		}
		return $this->addUsingAlias(PersonaPeer::TELEFONO, $telefono, $comparison);
	}

	/**
	 * Filter the query on the celular column
	 * 
	 * @param     string $celular The value to use as filter.
	 *            Accepts wildcards (* and % trigger a LIKE)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByCelular($celular = null, $comparison = null)
	{
		if (null === $comparison) {
			if (is_array($celular)) {
				$comparison = Criteria::IN;
			} elseif (preg_match('/[\%\*]/', $celular)) {
				$celular = str_replace('*', '%', $celular);
				$comparison = Criteria::LIKE;
			}
		}
		return $this->addUsingAlias(PersonaPeer::CELULAR, $celular, $comparison);
	}

	/**
	 * Filter the query on the calzado column
	 * 
	 * @param     string $calzado The value to use as filter.
	 *            Accepts wildcards (* and % trigger a LIKE)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByCalzado($calzado = null, $comparison = null)
	{
		if (null === $comparison) {
			if (is_array($calzado)) {
				$comparison = Criteria::IN;
			} elseif (preg_match('/[\%\*]/', $calzado)) {
				$calzado = str_replace('*', '%', $calzado);
				$comparison = Criteria::LIKE;
			}
		}
		return $this->addUsingAlias(PersonaPeer::CALZADO, $calzado, $comparison);
	}

	/**
	 * Filter the query on the pantalon column
	 * 
	 * @param     string $pantalon The value to use as filter.
	 *            Accepts wildcards (* and % trigger a LIKE)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByPantalon($pantalon = null, $comparison = null)
	{
		if (null === $comparison) {
			if (is_array($pantalon)) {
				$comparison = Criteria::IN;
			} elseif (preg_match('/[\%\*]/', $pantalon)) {
				$pantalon = str_replace('*', '%', $pantalon);
				$comparison = Criteria::LIKE;
			}
		}
		return $this->addUsingAlias(PersonaPeer::PANTALON, $pantalon, $comparison);
	}

	/**
	 * Filter the query on the camisa column
	 * 
	 * @param     string $camisa The value to use as filter.
	 *            Accepts wildcards (* and % trigger a LIKE)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByCamisa($camisa = null, $comparison = null)
	{
		if (null === $comparison) {
			if (is_array($camisa)) {
				$comparison = Criteria::IN;
			} elseif (preg_match('/[\%\*]/', $camisa)) {
				$camisa = str_replace('*', '%', $camisa);
				$comparison = Criteria::LIKE;
			}
		}
		return $this->addUsingAlias(PersonaPeer::CAMISA, $camisa, $comparison);
	}

	/**
	 * Filter the query on the observaciones column
	 * 
	 * @param     string $observaciones The value to use as filter.
	 *            Accepts wildcards (* and % trigger a LIKE)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByObservaciones($observaciones = null, $comparison = null)
	{
		if (null === $comparison) {
			if (is_array($observaciones)) {
				$comparison = Criteria::IN;
			} elseif (preg_match('/[\%\*]/', $observaciones)) {
				$observaciones = str_replace('*', '%', $observaciones);
				$comparison = Criteria::LIKE;
			}
		}
		return $this->addUsingAlias(PersonaPeer::OBSERVACIONES, $observaciones, $comparison);
	}

	/**
	 * Filter the query on the fecha_actualizacion column
	 * 
	 * @param     string|array $fechaActualizacion The value to use as filter.
	 *            Accepts an associative array('min' => $minValue, 'max' => $maxValue)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByFechaActualizacion($fechaActualizacion = null, $comparison = null)
	{
		if (is_array($fechaActualizacion)) {
			$useMinMax = false;
			if (isset($fechaActualizacion['min'])) {
				$this->addUsingAlias(PersonaPeer::FECHA_ACTUALIZACION, $fechaActualizacion['min'], Criteria::GREATER_EQUAL);
				$useMinMax = true;
			}
			if (isset($fechaActualizacion['max'])) {
				$this->addUsingAlias(PersonaPeer::FECHA_ACTUALIZACION, $fechaActualizacion['max'], Criteria::LESS_EQUAL);
				$useMinMax = true;
			}
			if ($useMinMax) {
				return $this;
			}
			if (null === $comparison) {
				$comparison = Criteria::IN;
			}
		}
		return $this->addUsingAlias(PersonaPeer::FECHA_ACTUALIZACION, $fechaActualizacion, $comparison);
	}

	/**
	 * Filter the query on the nacionalidad_id column
	 * 
	 * @param     int|array $nacionalidadId The value to use as filter.
	 *            Accepts an associative array('min' => $minValue, 'max' => $maxValue)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByNacionalidadId($nacionalidadId = null, $comparison = null)
	{
		if (is_array($nacionalidadId)) {
			$useMinMax = false;
			if (isset($nacionalidadId['min'])) {
				$this->addUsingAlias(PersonaPeer::NACIONALIDAD_ID, $nacionalidadId['min'], Criteria::GREATER_EQUAL);
				$useMinMax = true;
			}
			if (isset($nacionalidadId['max'])) {
				$this->addUsingAlias(PersonaPeer::NACIONALIDAD_ID, $nacionalidadId['max'], Criteria::LESS_EQUAL);
				$useMinMax = true;
			}
			if ($useMinMax) {
				return $this;
			}
			if (null === $comparison) {
				$comparison = Criteria::IN;
			}
		}
		return $this->addUsingAlias(PersonaPeer::NACIONALIDAD_ID, $nacionalidadId, $comparison);
	}

	/**
	 * Filter the query on the created_at column
	 * 
	 * @param     string|array $createdAt The value to use as filter.
	 *            Accepts an associative array('min' => $minValue, 'max' => $maxValue)
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByCreatedAt($createdAt = null, $comparison = null)
	{
		if (is_array($createdAt)) {
			$useMinMax = false;
			if (isset($createdAt['min'])) {
				$this->addUsingAlias(PersonaPeer::CREATED_AT, $createdAt['min'], Criteria::GREATER_EQUAL);
				$useMinMax = true;
			}
			if (isset($createdAt['max'])) {
				$this->addUsingAlias(PersonaPeer::CREATED_AT, $createdAt['max'], Criteria::LESS_EQUAL);
				$useMinMax = true;
			}
			if ($useMinMax) {
				return $this;
			}
			if (null === $comparison) {
				$comparison = Criteria::IN;
			}
		}
		return $this->addUsingAlias(PersonaPeer::CREATED_AT, $createdAt, $comparison);
	}

	/**
	 * Filter the query by a related Nacionalidad object
	 *
	 * @param     Nacionalidad $nacionalidad  the related object to use as filter
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByNacionalidad($nacionalidad, $comparison = null)
	{
		return $this
			->addUsingAlias(PersonaPeer::NACIONALIDAD_ID, $nacionalidad->getId(), $comparison);
	}

	/**
	 * Adds a JOIN clause to the query using the Nacionalidad relation
	 * 
	 * @param     string $relationAlias optional alias for the relation
	 * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function joinNacionalidad($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
	{
		$tableMap = $this->getTableMap();
		$relationMap = $tableMap->getRelation('Nacionalidad');
		
		// create a ModelJoin object for this join
		$join = new ModelJoin();
		$join->setJoinType($joinType);
		$join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
		if ($previousJoin = $this->getPreviousJoin()) {
			$join->setPreviousJoin($previousJoin);
		}
		
		// add the ModelJoin to the current object
		if($relationAlias) {
			$this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
			$this->addJoinObject($join, $relationAlias);
		} else {
			$this->addJoinObject($join, 'Nacionalidad');
		}
		
		return $this;
	}

	/**
	 * Use the Nacionalidad relation Nacionalidad object
	 *
	 * @see       useQuery()
	 * 
	 * @param     string $relationAlias optional alias for the relation,
	 *                                   to be used as main alias in the secondary query
	 * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
	 *
	 * @return    NacionalidadQuery A secondary query class using the current class as primary query
	 */
	public function useNacionalidadQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
	{
		return $this
			->joinNacionalidad($relationAlias, $joinType)
			->useQuery($relationAlias ? $relationAlias : 'Nacionalidad', 'NacionalidadQuery');
	}

	/**
	 * Filter the query by a related Media object
	 *
	 * @param     Media $media  the related object to use as filter
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByMedia($media, $comparison = null)
	{
		return $this
			->addUsingAlias(PersonaPeer::ID, $media->getPersonaId(), $comparison);
	}

	/**
	 * Adds a JOIN clause to the query using the Media relation
	 * 
	 * @param     string $relationAlias optional alias for the relation
	 * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function joinMedia($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
	{
		$tableMap = $this->getTableMap();
		$relationMap = $tableMap->getRelation('Media');
		
		// create a ModelJoin object for this join
		$join = new ModelJoin();
		$join->setJoinType($joinType);
		$join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
		if ($previousJoin = $this->getPreviousJoin()) {
			$join->setPreviousJoin($previousJoin);
		}
		
		// add the ModelJoin to the current object
		if($relationAlias) {
			$this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
			$this->addJoinObject($join, $relationAlias);
		} else {
			$this->addJoinObject($join, 'Media');
		}
		
		return $this;
	}

	/**
	 * Use the Media relation Media object
	 *
	 * @see       useQuery()
	 * 
	 * @param     string $relationAlias optional alias for the relation,
	 *                                   to be used as main alias in the secondary query
	 * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
	 *
	 * @return    MediaQuery A secondary query class using the current class as primary query
	 */
	public function useMediaQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
	{
		return $this
			->joinMedia($relationAlias, $joinType)
			->useQuery($relationAlias ? $relationAlias : 'Media', 'MediaQuery');
	}

	/**
	 * Filter the query by a related PersonaCasting object
	 *
	 * @param     PersonaCasting $personaCasting  the related object to use as filter
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByPersonaCasting($personaCasting, $comparison = null)
	{
		return $this
			->addUsingAlias(PersonaPeer::ID, $personaCasting->getPersonaId(), $comparison);
	}

	/**
	 * Adds a JOIN clause to the query using the PersonaCasting relation
	 * 
	 * @param     string $relationAlias optional alias for the relation
	 * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function joinPersonaCasting($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
	{
		$tableMap = $this->getTableMap();
		$relationMap = $tableMap->getRelation('PersonaCasting');
		
		// create a ModelJoin object for this join
		$join = new ModelJoin();
		$join->setJoinType($joinType);
		$join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
		if ($previousJoin = $this->getPreviousJoin()) {
			$join->setPreviousJoin($previousJoin);
		}
		
		// add the ModelJoin to the current object
		if($relationAlias) {
			$this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
			$this->addJoinObject($join, $relationAlias);
		} else {
			$this->addJoinObject($join, 'PersonaCasting');
		}
		
		return $this;
	}

	/**
	 * Use the PersonaCasting relation PersonaCasting object
	 *
	 * @see       useQuery()
	 * 
	 * @param     string $relationAlias optional alias for the relation,
	 *                                   to be used as main alias in the secondary query
	 * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
	 *
	 * @return    PersonaCastingQuery A secondary query class using the current class as primary query
	 */
	public function usePersonaCastingQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
	{
		return $this
			->joinPersonaCasting($relationAlias, $joinType)
			->useQuery($relationAlias ? $relationAlias : 'PersonaCasting', 'PersonaCastingQuery');
	}

	/**
	 * Filter the query by a related PersonaScouting object
	 *
	 * @param     PersonaScouting $personaScouting  the related object to use as filter
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByPersonaScouting($personaScouting, $comparison = null)
	{
		return $this
			->addUsingAlias(PersonaPeer::ID, $personaScouting->getPersonaId(), $comparison);
	}

	/**
	 * Adds a JOIN clause to the query using the PersonaScouting relation
	 * 
	 * @param     string $relationAlias optional alias for the relation
	 * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function joinPersonaScouting($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
	{
		$tableMap = $this->getTableMap();
		$relationMap = $tableMap->getRelation('PersonaScouting');
		
		// create a ModelJoin object for this join
		$join = new ModelJoin();
		$join->setJoinType($joinType);
		$join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
		if ($previousJoin = $this->getPreviousJoin()) {
			$join->setPreviousJoin($previousJoin);
		}
		
		// add the ModelJoin to the current object
		if($relationAlias) {
			$this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
			$this->addJoinObject($join, $relationAlias);
		} else {
			$this->addJoinObject($join, 'PersonaScouting');
		}
		
		return $this;
	}

	/**
	 * Use the PersonaScouting relation PersonaScouting object
	 *
	 * @see       useQuery()
	 * 
	 * @param     string $relationAlias optional alias for the relation,
	 *                                   to be used as main alias in the secondary query
	 * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
	 *
	 * @return    PersonaScoutingQuery A secondary query class using the current class as primary query
	 */
	public function usePersonaScoutingQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
	{
		return $this
			->joinPersonaScouting($relationAlias, $joinType)
			->useQuery($relationAlias ? $relationAlias : 'PersonaScouting', 'PersonaScoutingQuery');
	}

	/**
	 * Filter the query by a related PersonaLenguaje object
	 *
	 * @param     PersonaLenguaje $personaLenguaje  the related object to use as filter
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByPersonaLenguaje($personaLenguaje, $comparison = null)
	{
		return $this
			->addUsingAlias(PersonaPeer::ID, $personaLenguaje->getPersonaId(), $comparison);
	}

	/**
	 * Adds a JOIN clause to the query using the PersonaLenguaje relation
	 * 
	 * @param     string $relationAlias optional alias for the relation
	 * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function joinPersonaLenguaje($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
	{
		$tableMap = $this->getTableMap();
		$relationMap = $tableMap->getRelation('PersonaLenguaje');
		
		// create a ModelJoin object for this join
		$join = new ModelJoin();
		$join->setJoinType($joinType);
		$join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
		if ($previousJoin = $this->getPreviousJoin()) {
			$join->setPreviousJoin($previousJoin);
		}
		
		// add the ModelJoin to the current object
		if($relationAlias) {
			$this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
			$this->addJoinObject($join, $relationAlias);
		} else {
			$this->addJoinObject($join, 'PersonaLenguaje');
		}
		
		return $this;
	}

	/**
	 * Use the PersonaLenguaje relation PersonaLenguaje object
	 *
	 * @see       useQuery()
	 * 
	 * @param     string $relationAlias optional alias for the relation,
	 *                                   to be used as main alias in the secondary query
	 * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
	 *
	 * @return    PersonaLenguajeQuery A secondary query class using the current class as primary query
	 */
	public function usePersonaLenguajeQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
	{
		return $this
			->joinPersonaLenguaje($relationAlias, $joinType)
			->useQuery($relationAlias ? $relationAlias : 'PersonaLenguaje', 'PersonaLenguajeQuery');
	}

	/**
	 * Filter the query by a related PersonaLabel object
	 *
	 * @param     PersonaLabel $personaLabel  the related object to use as filter
	 * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function filterByPersonaLabel($personaLabel, $comparison = null)
	{
		return $this
			->addUsingAlias(PersonaPeer::ID, $personaLabel->getPersonaId(), $comparison);
	}

	/**
	 * Adds a JOIN clause to the query using the PersonaLabel relation
	 * 
	 * @param     string $relationAlias optional alias for the relation
	 * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function joinPersonaLabel($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
	{
		$tableMap = $this->getTableMap();
		$relationMap = $tableMap->getRelation('PersonaLabel');
		
		// create a ModelJoin object for this join
		$join = new ModelJoin();
		$join->setJoinType($joinType);
		$join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
		if ($previousJoin = $this->getPreviousJoin()) {
			$join->setPreviousJoin($previousJoin);
		}
		
		// add the ModelJoin to the current object
		if($relationAlias) {
			$this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
			$this->addJoinObject($join, $relationAlias);
		} else {
			$this->addJoinObject($join, 'PersonaLabel');
		}
		
		return $this;
	}

	/**
	 * Use the PersonaLabel relation PersonaLabel object
	 *
	 * @see       useQuery()
	 * 
	 * @param     string $relationAlias optional alias for the relation,
	 *                                   to be used as main alias in the secondary query
	 * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
	 *
	 * @return    PersonaLabelQuery A secondary query class using the current class as primary query
	 */
	public function usePersonaLabelQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
	{
		return $this
			->joinPersonaLabel($relationAlias, $joinType)
			->useQuery($relationAlias ? $relationAlias : 'PersonaLabel', 'PersonaLabelQuery');
	}

	/**
	 * Exclude object from result
	 *
	 * @param     Persona $persona Object to remove from the list of results
	 *
	 * @return    PersonaQuery The current query, for fluid interface
	 */
	public function prune($persona = null)
	{
		if ($persona) {
			$this->addUsingAlias(PersonaPeer::ID, $persona->getId(), Criteria::NOT_EQUAL);
	  }
	  
		return $this;
	}

} // BasePersonaQuery
